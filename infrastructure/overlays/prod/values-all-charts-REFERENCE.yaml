# gitops-platform/infrastructure/overlays/prod/values.yaml
# Production environment - HA, large resources, monitoring

global:
  environment: prod
  storageClass: "premium-rwo"

# PostgreSQL
postgresql:
  enabled: true
  image:
    registry: docker.io
    repository: postgres
    tag: 15
    pullPolicy: IfNotPresent
  architecture: replication
  auth:
    existingSecret: postgres-credentials
    replicationPasswordKey: repmgr-password
  primary:
    persistence:
      size: 100Gi
      storageClass: "premium-rwo"
    resources:
      requests:
        memory: 2Gi
        cpu: 1000m
      limits:
        memory: 4Gi
        cpu: 2000m
    nodeSelector:
      workload: stateful
  readReplicas:
    replicaCount: 2
    persistence:
      size: 100Gi
      storageClass: "premium-rwo"
    resources:
      requests:
        memory: 2Gi
        cpu: 1000m
      limits:
        memory: 4Gi
        cpu: 2000m
  backup:
    enabled: true
    cronjob:
      schedule: "0 2 * * *"
      resources:
        requests:
          memory: 512Mi
          cpu: 250m
  metrics:
    enabled: true
    serviceMonitor:
      enabled: true
  initdbScripts:
    create-databases.sql: |
      CREATE DATABASE authdb;
      CREATE DATABASE paymentdb;
      CREATE DATABASE bookingdb;
      CREATE DATABASE roomdb;
      CREATE DATABASE walletdb;

# Kafka (KRaft mode - no Zookeeper)
kafka:
  enabled: true
  image:
    registry: docker.io
    repository: apache/kafka
    tag: 4.1.1
    pullPolicy: IfNotPresent
  replicaCount: 3
  persistence:
    size: 100Gi
    storageClass: "premium-rwo"
  resources:
    requests:
      memory: 4Gi
      cpu: 2000m
    limits:
      memory: 8Gi
      cpu: 4000m
  kraft:
    enabled: true
    processRoles: "broker,controller"
    controllerQuorumVoters: "1@kafka-0.kafka-headless.infrastructure.svc.cluster.local:9093,2@kafka-1.kafka-headless.infrastructure.svc.cluster.local:9093,3@kafka-2.kafka-headless.infrastructure.svc.cluster.local:9093"
  listeners:
    client:
      protocol: PLAINTEXT
      containerPort: 9092
    controller:
      protocol: PLAINTEXT
      containerPort: 9093
  environment:
    KAFKA_NODE_ID: "$(POD_NAME)"
    KAFKA_CONTROLLER_QUORUM_VOTERS: "1@kafka-0:9093,2@kafka-1:9093,3@kafka-2:9093"
    KAFKA_PROCESS_ROLES: "broker,controller"
    CLUSTER_ID: "PROD-MkU3OEVBNTcwNTJENDM2Qk"
  metrics:
    enabled: true
    serviceMonitor:
      enabled: true

# Redis
redis:
  enabled: true
  image:
    registry: docker.io
    repository: redis
    tag: 7
    pullPolicy: IfNotPresent
  architecture: replication
  auth:
    enabled: true
    existingSecret: redis-credentials
    existingSecretPasswordKey: password
  master:
    persistence:
      size: 50Gi
      storageClass: "premium-rwo"
    resources:
      requests:
        memory: 1Gi
        cpu: 1000m
      limits:
        memory: 2Gi
        cpu: 2000m
  replica:
    replicaCount: 2
    persistence:
      size: 50Gi
      storageClass: "premium-rwo"
    resources:
      requests:
        memory: 1Gi
        cpu: 500m
      limits:
        memory: 2Gi
        cpu: 1000m
  metrics:
    enabled: true
    serviceMonitor:
      enabled: true

# RabbitMQ
rabbitmq:
  enabled: true
  image:
    registry: docker.io
    repository: rabbitmq
    tag: 3.13-management
    pullPolicy: IfNotPresent
  replicaCount: 3
  persistence:
    size: 50Gi
    storageClass: "premium-rwo"
  resources:
    requests:
      memory: 2Gi
      cpu: 1000m
    limits:
      memory: 4Gi
      cpu: 2000m
  auth:
    existingSecret: rabbitmq-credentials
    existingSecretPasswordKey: rabbitmq-password
  extraPlugins: "rabbitmq_management rabbitmq_peer_discovery_k8s rabbitmq_prometheus"
  extraConfiguration: |
    default_vhost = microservice_one
    cluster_formation.peer_discovery_backend = rabbit_peer_discovery_k8s
    cluster_formation.k8s.host = kubernetes.default.svc.cluster.local
    cluster_formation.k8s.address_type = hostname
  loadDefinition:
    enabled: true
    file: /app/load_definition.json
  extraSecrets:
    load-definition:
      data: |
        {
          "vhosts": [{"name": "microservice_one"}],
          "queues": [{"name": "microservice_one.events", "vhost": "microservice_one", "durable": true}],
          "exchanges": [
            {"name": "booking.events", "vhost": "microservice_one", "type": "topic", "durable": true},
            {"name": "post_service.events", "vhost": "microservice_one", "type": "topic", "durable": true}
          ]
        }
  metrics:
    enabled: true
    serviceMonitor:
      enabled: true
  podDisruptionBudget:
    enabled: true
    minAvailable: 2

# Traefik
traefik:
  enabled: true
  image:
    name: traefik
    tag: v2.11
    pullPolicy: IfNotPresent
  deployment:
    replicas: 2
  service:
    type: LoadBalancer
    annotations:
      service.beta.kubernetes.io/aws-load-balancer-type: "nlb"
      service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled: "true"
  logs:
    general:
      level: ERROR
    access:
      enabled: true
  metrics:
    prometheus:
      addRoutersLabels: true
      addServicesLabels: true
      entryPoint: metrics
  ingressRoute:
    dashboard:
      enabled: false
  certificatesResolvers:
    letsencrypt:
      acme:
        email: prod-admin@example.com
        storage: /data/acme.json
        httpChallenge:
          entryPoint: web
  additionalArguments:
    - "--metrics.prometheus=true"
    - "--entryPoints.metrics.address=:8080"
  ports:
    web:
      port: 80
      expose: true
      redirections:
        entryPoint:
          to: websecure
          scheme: https
    websecure:
      port: 443
      expose: true
    metrics:
      port: 8080
      expose: true
  resources:
    requests:
      memory: 512Mi
      cpu: 500m
    limits:
      memory: 1Gi
      cpu: 1000m
  affinity:
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 100
          podAffinityTerm:
            labelSelector:
              matchLabels:
                app.kubernetes.io/name: traefik
            topologyKey: kubernetes.io/hostname